#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod impls {
    use std::collections::BTreeMap;
    use std::collections::HashMap;
    use crate::KType;
    use crate::Schema;
    impl Schema for i8 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for i16 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for i32 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for i64 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for i128 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for u8 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for u16 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for u32 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for u64 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for u128 {
        fn schema() -> crate::KType {
            KType::Number
        }
    }
    impl Schema for String {
        fn schema() -> crate::KType {
            KType::String
        }
    }
    impl Schema for &str {
        fn schema() -> crate::KType {
            KType::String
        }
    }
    impl<T: Schema> Schema for Vec<T> {
        fn schema() -> KType {
            KType::List(Box::new(T::schema()))
        }
    }
    impl<V, K> Schema for HashMap<K, V> {
        fn schema() -> KType {
            KType::Map
        }
    }
    impl<V, K> Schema for BTreeMap<K, V> {
        fn schema() -> KType {
            KType::Map
        }
    }
    impl Schema for bool {
        fn schema() -> KType {
            KType::Bool
        }
    }
}
use std::collections::BTreeMap;
use k_onfig_derive::Konfig;
pub enum KType {
    Bool,
    Map,
    Object(BTreeMap<&'static str, KType>),
    Number,
    String,
    List(Box<KType>),
    None,
}
#[automatically_derived]
impl ::core::clone::Clone for KType {
    #[inline]
    fn clone(&self) -> KType {
        match self {
            KType::Bool => KType::Bool,
            KType::Map => KType::Map,
            KType::Object(__self_0) => {
                KType::Object(::core::clone::Clone::clone(__self_0))
            }
            KType::Number => KType::Number,
            KType::String => KType::String,
            KType::List(__self_0) => KType::List(::core::clone::Clone::clone(__self_0)),
            KType::None => KType::None,
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for KType {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            KType::Bool => ::core::fmt::Formatter::write_str(f, "Bool"),
            KType::Map => ::core::fmt::Formatter::write_str(f, "Map"),
            KType::Object(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Object", &__self_0)
            }
            KType::Number => ::core::fmt::Formatter::write_str(f, "Number"),
            KType::String => ::core::fmt::Formatter::write_str(f, "String"),
            KType::List(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "List", &__self_0)
            }
            KType::None => ::core::fmt::Formatter::write_str(f, "None"),
        }
    }
}
#[automatically_derived]
impl ::core::marker::StructuralEq for KType {}
#[automatically_derived]
impl ::core::cmp::Eq for KType {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {
        let _: ::core::cmp::AssertParamIsEq<BTreeMap<&'static str, KType>>;
        let _: ::core::cmp::AssertParamIsEq<Box<KType>>;
    }
}
#[automatically_derived]
impl ::core::hash::Hash for KType {
    #[inline]
    fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        ::core::hash::Hash::hash(&__self_tag, state);
        match self {
            KType::Object(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            KType::List(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            _ => {}
        }
    }
}
#[automatically_derived]
impl ::core::cmp::Ord for KType {
    #[inline]
    fn cmp(&self, other: &KType) -> ::core::cmp::Ordering {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        match ::core::cmp::Ord::cmp(&__self_tag, &__arg1_tag) {
            ::core::cmp::Ordering::Equal => {
                match (self, other) {
                    (KType::Object(__self_0), KType::Object(__arg1_0)) => {
                        ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                    }
                    (KType::List(__self_0), KType::List(__arg1_0)) => {
                        ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                    }
                    _ => ::core::cmp::Ordering::Equal,
                }
            }
            cmp => cmp,
        }
    }
}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for KType {}
#[automatically_derived]
impl ::core::cmp::PartialEq for KType {
    #[inline]
    fn eq(&self, other: &KType) -> bool {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        __self_tag == __arg1_tag
            && match (self, other) {
                (KType::Object(__self_0), KType::Object(__arg1_0)) => {
                    *__self_0 == *__arg1_0
                }
                (KType::List(__self_0), KType::List(__arg1_0)) => *__self_0 == *__arg1_0,
                _ => true,
            }
    }
}
#[automatically_derived]
impl ::core::cmp::PartialOrd for KType {
    #[inline]
    fn partial_cmp(
        &self,
        other: &KType,
    ) -> ::core::option::Option<::core::cmp::Ordering> {
        let __self_tag = ::core::intrinsics::discriminant_value(self);
        let __arg1_tag = ::core::intrinsics::discriminant_value(other);
        match (self, other) {
            (KType::Object(__self_0), KType::Object(__arg1_0)) => {
                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
            }
            (KType::List(__self_0), KType::List(__arg1_0)) => {
                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
            }
            _ => ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag),
        }
    }
}
pub trait Schema {
    fn schema() -> KType;
}
struct Hello {
    hello: Bye,
    content: String,
}
struct Bye {
    bye: i32,
    hello: bool,
}
impl Schema for Bye {
    fn schema() -> crate::KType {
        let map: BTreeMap<&'static str, KType> = ::std::collections::BTreeMap::new();
        map.insert("bye", i32::schema());
        map.insert("hello", bool::schema());
        KType::Object(map)
    }
}
